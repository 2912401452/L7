"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var POST_CONSTRUCT_KEY = "post_construct";
var TAGGED_PROPS_KEY = "inversify:tagged_props";
var CONTEXT_KEY = "inversify-logging:context";
var INIT_LOGGER = "__logger_init";
var lodash_1 = require("lodash");
function LoggingContext(context) {
    return function (target) {
        Reflect.defineMetadata(CONTEXT_KEY, context, target);
        target.prototype[INIT_LOGGER] = initContextLogger;
        Reflect.defineMetadata(POST_CONSTRUCT_KEY, {
            key: POST_CONSTRUCT_KEY,
            value: INIT_LOGGER
        }, target);
        return target;
    };
}
exports.LoggingContext = LoggingContext;
// This workaround is needed because inversify currently does not provide the current request when binding
// a service with toDynamicValue
function initContextLogger() {
    var properties = Reflect.getMetadata(TAGGED_PROPS_KEY, this.constructor), loggerPropertyName = lodash_1.find(lodash_1.keys(properties), function (key) {
        return lodash_1.find(properties[key], function (metadata) { return (metadata.key === "inject" || metadata.key === "lazy_inject") && metadata.value === "ILogger"; });
    });
    if (!this[loggerPropertyName])
        return;
    this[loggerPropertyName] = this[loggerPropertyName].createChildLogger(Reflect.getMetadata(CONTEXT_KEY, this.constructor));
}
exports.initContextLogger = initContextLogger;
